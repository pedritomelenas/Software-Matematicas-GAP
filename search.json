[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAP - Software matemáticas",
    "section": "",
    "text": "Bloque de GAP de la asignatura Software Matemáticas del máster Matemáticas.\nEn la página oficial de GAP se explica cómo instalar GAP para distintos sistemas operativos. En dicha página también hay manuales y tutoriales tanto de GAP como de las distintas libreras oficiales.\nGAP está integrado en SageMath, así que si tenéis instalado SageMath, podéis ejecutar GAP con sage --gap.\nParte de este curso está inspirado en el curso que di en Badajoz en 2009.\nEl fichero Dockerfile está extraido del ejemplo binder de @sebasguts para GAP y vis.js.\nPara escribir código podéis utilizar Visual Studio Code."
  },
  {
    "objectID": "3 Enteros de Gauss.html",
    "href": "3 Enteros de Gauss.html",
    "title": "Enteros de Gauss",
    "section": "",
    "text": "En este bloc mostramos los comandos básicos para trabajar con aritmética entera modular.\nAntes de empezar vamos a cambiar la forma en la que se representan los complejos en GAP. GAP utiliza E(4) para referirse a \\(i\\) (raíz cuarta de la unidad, de ahí la notación).\nInstallMethod(ViewString, [IsCyc], function(n) \n    local a,b;\n    a:=RealPart(n);\n    b:=ImaginaryPart(n);\n    if a=0 then \n        if b=1 then \n            return \"i\";\n        fi;\n        return Concatenation(String(b),\" i\");\n    fi;\n    if b=0 then \n        return String(a);\n    fi;\n    if b&lt;0 then\n        return Concatenation(String(a),\" - \",String(-b),\" i\");\n    elif b=1 then\n        return Concatenation(String(a),\" + i\");\n    else\n        return Concatenation(String(a),\" + \",String(b),\" i\");\n    fi;\n    end\n    );\ni:=E(4);\n\ni",
    "crumbs": [
      "Enteros de Gauss"
    ]
  },
  {
    "objectID": "3 Enteros de Gauss.html#cociente-y-resto",
    "href": "3 Enteros de Gauss.html#cociente-y-resto",
    "title": "Enteros de Gauss",
    "section": "Cociente y resto",
    "text": "Cociente y resto\nDados dos enteros de Gauss \\(a\\) y \\(b\\), el cociente y el resto se pueden obtener con EuclideanQuotient y EuclideanRemainder.\n\nEuclideanQuotient(3+i,1-2*i);\n\ni\n\n\n\nEuclideanRemainder(3+i,1-2*i);\n\n1\n\n\n\n(-3+i)/(1+i);\n\n-1 + 2 i\n\n\nEn cualquier dominio euclídeo también se puede utilizar QuotientRemainder.\n\nQuotientRemainder(GaussianIntegers,3+E(4),1-2*E(4));\n\n[ i, 1 ]\n\n\nPodemos usar Int para obtener la parte “entera” de un cociente.\n\nInt((27-23*E(4))/(8+E(4)));\n\n2 - 3 i\n\n\nPero hay que tener en cuenta que éste no tiene por qué ser el cociente de la división. Vemoas qué norma tiene el resto.\n\nN:=x-&gt;x*ComplexConjugate(x);\n\nfunction( x ) ... end\n\n\n\na:=27-23*i;\nb:=8+i;\nr:=a-Int(a/b)*b;\n\n27 - 23 i\n\n\n8 + i\n\n\n8 - 1 i\n\n\n\nN(b);\n\n65\n\n\n\nN(r);\n\n65",
    "crumbs": [
      "Enteros de Gauss"
    ]
  },
  {
    "objectID": "3 Enteros de Gauss.html#máximo-común-divisor-y-mínimo-común-múltiplo.-coeficientes-de-bézout",
    "href": "3 Enteros de Gauss.html#máximo-común-divisor-y-mínimo-común-múltiplo.-coeficientes-de-bézout",
    "title": "Enteros de Gauss",
    "section": "Máximo común divisor y mínimo común múltiplo. Coeficientes de Bézout",
    "text": "Máximo común divisor y mínimo común múltiplo. Coeficientes de Bézout\nEl máximo común divisor de dos enteros de Guass (o más) puede ser calculado con el comando Gcd, y su mínimo común múltiplo con el comando Lcm, tal y como lo hacíamos con enteros racionales.\n\nGcd(3+i,-5-2*i);\n\n1\n\n\n\nLcm(3+i,-15-3*i);\n\n9 + 33 i\n\n\nSi queremos conseguir los coeficientes de Bézout, podemos usar el comando GcdRepresentation (entre las muchas posibilidades que da gap para esto).\n\nl:=GcdRepresentation(3+i,-5-2*i);\n\n[ 2, 1 ]\n\n\nComprobemos el resultado\n\nl*[3+i,-5-2*i];\n\n1\n\n\n\nGcdRepresentation(10-5*i,15+10*i,18-5*i);\n\n[ 5 - 25 i, 14 + 8 i, -3 ]\n\n\n\nEcuaciones lineales\nComo ya sabemos, una vez resuelto el problema de encontrar los coeficientes de Bézout de un máximo común divisor de dos enteros de Gauss, tenemos también solución para resolver una ecuación lineal en dos variables. Lo único que tenemos que comprobar es si el término independiente es divisible por el máximo común divisor de los coeficientes, y luego multiplicar los coeficientes de Bézout por el factor apropiado para conseguir una solución particular.\nSi queremos resolver \\(4 x+ (3+3i) y= -1+5i\\), hacemos lo siguiente.\n\n(-1+5*i)/Gcd(4,3+3*i);\n\n2 + 3 i\n\n\nLuego una solución se obtiene fácilmente usando los coeficientes de Bézout.\n\ns:=GcdRepresentation(4,3+3*i)*(-1+5*i)/Gcd(4,3+3*i);;\n\nPodemos ver que el resultado es el correcto.\n\ns*[4,3+3*i];\n\n-1 + 5 i",
    "crumbs": [
      "Enteros de Gauss"
    ]
  },
  {
    "objectID": "3 Enteros de Gauss.html#factorizaciones-y-primos",
    "href": "3 Enteros de Gauss.html#factorizaciones-y-primos",
    "title": "Enteros de Gauss",
    "section": "Factorizaciones y primos",
    "text": "Factorizaciones y primos\nPara factorizar un entero en producto de primos podemos usar el comando Factors.\n\nFactors(20+18*i);\n\n[ 1 - 1 i, 1 + i, 10 + 9 i ]\n\n\nTambién podemos saber si un número es primo usando el comando IsPrime. Pero tenemos que tener cuidado con especificar el anillo en que queremos comprobar la primalidad cuando se trate de enteros.\n\nIsPrime(5);\n\ntrue\n\n\n\nIsPrime(GaussianIntegers,5);\n\nfalse",
    "crumbs": [
      "Enteros de Gauss"
    ]
  },
  {
    "objectID": "3 Enteros de Gauss.html#congruencias",
    "href": "3 Enteros de Gauss.html#congruencias",
    "title": "Enteros de Gauss",
    "section": "Congruencias",
    "text": "Congruencias\nPara resolver una ecuación en recurrencias podemos usar GcdRepresentation como hicimos arriba con una ecuación lineal.\nSi lo que queremos es resolver un sistema de congruencias de la forma \\[\n\\begin{array}{l}\nx\\equiv a_1\\bmod m_1,\\\\\n\\dots\\\\\nx\\equiv a_n\\bmod m_n,\n\\end{array}\n\\] en el caso de enteros de Gauss lo podemos hacer resolviendo una a una las ecuaciones y poniendo en la siguiente la solución para determinar el valor del parámetro. Así, para resolver \\[\n\\begin{array}{l}\nx\\equiv i\\bmod 3,\\\\\nx\\equiv 1+i \\bmod 5+2i,\n\\end{array}\n\\] hacemos lo siguiente.\nDe la primera ecuación deducimos que \\(x=i+3t\\) para algún \\(t\\in \\mathbb{Z}[i]\\).\nSustituimos en la segunda y obtenemos \\(i+3t\\equiv 1+i \\bmod{5+2i}\\). Por lo que tenemos que resolver \\(3t\\equiv 1\\bmod{5+2i}\\).\n\nGcd(3,5+2*i);\n\n1\n\n\n\nGcdRepresentation(3,5+2*i);\n\n[ -2 + i, 1 - 1 i ]\n\n\nEsto nos dice que el inverso de \\(3\\) módulo \\(5+2i\\) es \\(-2+i\\). Así, nos queda \\(t\\equiv -2+i \\bmod{5+2i}\\), o lo que es lo mismo, \\(t=-2+i+(5+2i)s\\) para algún \\(s\\in \\mathbb{Z}[i]\\). Por tanto, \\(x=i+3(-2+i+(5+2i)s)=-6+4i+(15+6i)s\\) con \\(s\\in\\mathbb{Z}[i]\\)\nComprobemos que la solución particular \\(-6+4i\\) está bien.\n\nEuclideanRemainder(-6+4*i-i,3);\n\n0\n\n\n\nEuclideanRemainder(-6+4*i-(1+i),5+2*i);\n\n0",
    "crumbs": [
      "Enteros de Gauss"
    ]
  },
  {
    "objectID": "7 Matrices-espacios-vectoriales.html",
    "href": "7 Matrices-espacios-vectoriales.html",
    "title": "Matrices y espacios vectoriales",
    "section": "",
    "text": "Las matrices en gap se representan como una lista de listas, de forma que todas ellas tengan la misma longitud y el mismo tipo de elementos. Por tanto hay que tener cuidado con qué comandos son ‘destructivos’. La suma, producto e inverso se calculan con las operaciones usuales.\nEsto cambiará en las versiones futuras de gap (véase el proyecto MatrixObj).\na:=[[1,2],[3,4]];\nb:=[[5,6],[7,8]];\n\n[ [ 1, 2 ], [ 3, 4 ] ]\n\n\n[ [ 5, 6 ], [ 7, 8 ] ]\na+b;\n\n[ [ 6, 8 ], [ 10, 12 ] ]\na*b;\n\n[ [ 19, 22 ], [ 43, 50 ] ]\na^(-1);\n\n[ [ -2, 1 ], [ 3/2, -1/2 ] ]\na^0;\n\n[ [ 1, 0 ], [ 0, 1 ] ]\nY el determinante\nDeterminant(a);\n\n-2\nPara calcular la forma normal de Hermite sobre los enteros disponemos de la siguiente función.\na:=[[1,2,3],[4,5,6]];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nHermiteNormalFormIntegerMat(a);\n\n[ [ 1, 2, 3 ], [ 0, 3, 6 ] ]\nSi queremos las matrices te transformaciones para llegar a la forma de Hermite:\nHermiteNormalFormIntegerMatTransform(a);\n\nrec( normal := [ [ 1, 2, 3 ], [ 0, 3, 6 ] ], rank := 2, rowC := [ [ 1, 0 ], [ 0, 1 ] ], rowQ := [ [ 1, 0 ], [ 4, -1 ] ], rowtrans := [ [ 1, 0 ], [ 4, -1 ] ] )\nSi queremos hacer el cálculo sobre los racionales, usamos TriangulizeMat, pero ojo, que esta función destruye el argumento que le pasamos.\na:=[[1,2,3],[4,5,6]];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nTriangulizeMat(a);\na;\n\n[ [ 1, 0, -1 ], [ 0, 1, 2 ] ]\nCon TriangulizedMat el argumento no se modifica.\na:=[[1,2,3],[4,5,6]];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nTriangulizedMat(a);\n\n[ [ 1, 0, -1 ], [ 0, 1, 2 ] ]\nP:=PolynomialRing(Rationals,\"x\");;\na:=[[1,2,3],[4,5,x]];\n\n[ [ 1, 2, 3 ], [ 4, 5, x ] ]\nx:=Indeterminate(Rationals,\"x\");;\nTriangulizedMat(a);\n\nError, no method found! For debugging hints type ?Recovery from NoMethodFound\nError, no 1st choice method found for `TriangulizedMat' on 1 arguments at /home/pedro/lib/gap-4.10.0/lib/methsel2.g:250 called from\n&lt;function \"HANDLE_METHOD_NOT_FOUND\"&gt;( &lt;arguments&gt; )\n called from read-eval loop at stream:1\nEl error se debe a que en este caso a es una lista de listas con enteros (que no se consideran polinomios) y un polinomio (x). Para arreglar esto, multiplicamos toda la matriz por One(P) convirtiendo todos los enteros en polinomios (constantes).\nTriangulizedMat(a*One(P));\n\n[ [ 1, 0, 2/3*x-5 ], [ 0, 1, -1/3*x+4 ] ]\nSi queremos hacer las cuentas sobre un cuerpo finito, podemos usar el comando GF (cuerpo de Galois), y luego embeber la matriz dada en dicho cuerpo con One.\nF:=GF(7);\n\nGF(7)\na:=[[1,2,3],[4,5,6]];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\naz7:=a*One(F);\n\n[ [ Z(7)^0, Z(7)^2, Z(7) ], [ Z(7)^4, Z(7)^5, Z(7)^3 ] ]\nTriangulizeMat(az7);\naz7;\n\n[ [ Z(7)^0, 0*Z(7), Z(7)^3 ], [ 0*Z(7), Z(7)^0, Z(7)^2 ] ]\nTeachingMode(true);\n\n\u0003#I  \u0003\u0003Teaching mode is turned \u0003\u0003ON\u0003\u0003\n\u0003\naz7;\n\n[ [ ZmodnZObj(1,7), ZmodnZObj(0,7), ZmodnZObj(6,7) ], [ ZmodnZObj(0,7), ZmodnZObj(1,7), ZmodnZObj(2,7) ] ]\na;\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\nNótese que a no ha sido destruida, pues la operación a*One(F) genera una nueva matriz a partir de ella.",
    "crumbs": [
      "Matrices y espacios vectoriales"
    ]
  },
  {
    "objectID": "7 Matrices-espacios-vectoriales.html#sistemas-de-ecuaciones",
    "href": "7 Matrices-espacios-vectoriales.html#sistemas-de-ecuaciones",
    "title": "Matrices y espacios vectoriales",
    "section": "Sistemas de ecuaciones",
    "text": "Sistemas de ecuaciones\nPara encontrar una solución de un sistema de la forma \\(x A=b\\) usando gap, utilizamos el comando SolutionMat junto con NullspaceMat. El primero nos da una solución particular (en caso de existir) y el segundo nos da las soluciones del sistema homogéneo asociado.\n\na:=[[1,2,3],[4,5,6]]; b:=[1,1,1];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n\n\n[ 1, 1, 1 ]\n\n\n\nSolutionMat(a,b);\n\n[ -1/3, 1/3 ]\n\n\n\nNullspaceMat(a);\n\n[  ]\n\n\nCon lo que en este caso la solución es única.\n\na:=[[1,2],[3,4],[5,6]];b:=[1,1];\n\n[ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]\n\n\n[ 1, 1 ]\n\n\n\nSolutionMat(a,b);\n\n[ -1/2, 1/2, 0 ]\n\n\n\nNullspaceMat(a);\n\n[ [ 1, -2, 1 ] ]\n\n\nY en este caso las soluciones son de la forma \\((-\\frac{1}2,\\frac{1}2,0)+\\lambda (1,-2,1)\\).\nEn caso de no existir solución recibimos un fail a cambio.\n\na:=[[1,2,3],[4,5,6]]; b:=[1,1,2];\n\n[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n\n\n[ 1, 1, 2 ]\n\n\n\nSolutionMat(a,b);\n\nfail\n\n\nTambién podemos hacer las cuentas sobre un cuerpo finito.\n\na:=[[1,2],[3,4],[5,6]];b:=[1,1];\n\n[ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]\n\n\n[ 1, 1 ]\n\n\n\nF:=GF(5);\n\nGF(5)\n\n\n\nSolutionMat(a*One(F),b*One(F));\n\n[ ZmodnZObj(2,5), ZmodnZObj(3,5), ZmodnZObj(0,5) ]",
    "crumbs": [
      "Matrices y espacios vectoriales"
    ]
  },
  {
    "objectID": "7 Matrices-espacios-vectoriales.html#espacios-vectoriales",
    "href": "7 Matrices-espacios-vectoriales.html#espacios-vectoriales",
    "title": "Matrices y espacios vectoriales",
    "section": "Espacios vectoriales",
    "text": "Espacios vectoriales\ngap ya sabe que algunos de sus objetos son espacios vectoriales, y además podemos definir nuevos espacios vectoriales de diferentes formas.\n\nInstallMethod(ViewString, [IsPolynomial], String);\nInstallMethod(ViewString, [IsVectorSpace], function(v) return(\"Espacio vectorial\"); end);\nInstallMethod(ViewString, [IsSubspacesVectorSpace], function(v) return(\"Subespacios vectoriales\"); end);\nInstallMethod(ViewString, [IsGeneralMapping], function(v) return(\"Aplicación\"); end);\n\n\nx:=Indeterminate(Rationals,\"x\");\n\nx\n\n\n\nP:=PolynomialRing(Rationals,[x]);\n\nRationals[x]\n\n\n\nIsVectorSpace(P);\n\ntrue\n\n\n\nIsVectorSpace(Rationals^4);\n\ntrue\n\n\n\nV:=VectorSpace(Rationals, [[1,2,3],[4,5,6]]);\n\nEspacio vectorial\n\n\n\n[3,3,3] in V;\n\ntrue\n\n\n\nB:=Basis(V);\n\n[ [ 1, 2, 3 ], [ 0, 1, 2 ] ]\n\n\n\nDimension(V);\n\n2\n\n\nTambién podemos calcular los coeficientes de un vector respecto de una base, o las combinaciones lineales de los elementos de una base.\n\nCoefficients(B,[1,1,1]);\n\n[ 1, -1 ]\n\n\n\nCoefficients(B,[1,0,1]);\n\nfail\n\n\n\nLinearCombination(B,[1,1]);\n\n[ 1, 3, 5 ]\n\n\nLos subespacios se pueden definir con la orden Subspace, y los cocientes se hacen como en grupos.\n\nV:=Rationals^4;\n\n( Rationals^4 )\n\n\n\nW:=Subspace(V,[[1,2,3,4],[1,1,1,1]]);\n\nEspacio vectorial\n\n\nPodemos hacer cocientes:\n\nV/W;\n\n( Rationals^2 )\n\n\nTambién intersecciones y sumas\n\nU:=Subspace(V,[[3,3,3,3],[2,2,0,0]]);\n\nEspacio vectorial\n\n\n\nIntersection(U,W);\n\nEspacio vectorial\n\n\n\nBasis(Intersection(U,W));\n\n[ [ 1, 1, 1, 1 ] ]\n\n\n\nBasis(U+W);\n\n[ [ 1, 1, 1, 1 ], [ 0, 1, 0, 1 ], [ 0, 0, 1, 1 ] ]\n\n\nSi nuestro espacio vectorial es finito, podemos calcular todos sus subespacios.\n\nsz22:= Subspaces(GF(2)^2);\n\nSubespacios vectoriales\n\n\n\nList(sz22,w-&gt;BasisVectors(Basis(w)));\n\n[ [  ], [ [ ZmodnZObj(1,2), ZmodnZObj(0,2) ] ], [ [ ZmodnZObj(1,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(1,2), ZmodnZObj(0,2) ], [ ZmodnZObj(0,2), ZmodnZObj(1,2) ] ] ]\n\n\n\nList(sz22,w-&gt;Basis(w));\n\n[ [  ], [ [ ZmodnZObj(1,2), ZmodnZObj(0,2) ] ], [ [ ZmodnZObj(1,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(1,2), ZmodnZObj(0,2) ], [ ZmodnZObj(0,2), ZmodnZObj(1,2) ] ] ]\n\n\n\nList(sz22,Elements);\n\n[ [ [ ZmodnZObj(0,2), ZmodnZObj(0,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(0,2) ], [ ZmodnZObj(1,2), ZmodnZObj(0,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(0,2) ], [ ZmodnZObj(1,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(0,2) ], [ ZmodnZObj(0,2), ZmodnZObj(1,2) ] ], [ [ ZmodnZObj(0,2), ZmodnZObj(0,2) ], [ ZmodnZObj(0,2), ZmodnZObj(1,2) ], [ ZmodnZObj(1,2), ZmodnZObj(0,2) ], [ ZmodnZObj(1,2), ZmodnZObj(1,2) ] ] ]\n\n\nPara definir una aplicación lineal entre subespacios podemos usar la función LeftModuleGeneralMappingByImages, pues en gap, los espacios vectoriales son considerados como módulos a izquierda.\nUn complemento de un subespacio \\(W\\) de \\(V\\) lo podemos calcular usando el homomorfismo natural de \\(V\\) a \\(V/W\\).\n\nV:=Rationals^4;\nW:=Subspace(V,[[1,0,0,0],[0,0,0,1]]);\np:=NaturalHomomorphismBySubspace(V,W);\n\n( Rationals^4 )\n\n\nEspacio vectorial\n\n\nAplicación\n\n\n\nPreImagesRepresentative(p,[1,0]);\n\n[ 0, 1, 0, 0 ]\n\n\n\nPreImagesRepresentative(p,[0,1]);\n\n[ 0, 0, 1, 0 ]\n\n\nAl no ser la aplicación biyectiva no podemos usar PreImage a secas.\n\nV1:=Rationals^4;;\nV2:=VectorSpace(Rationals,[[1,2],[3,4]]);;\nf:=LeftModuleGeneralMappingByImages(V1,V2,Basis(V1), [[1,2],[3,4],[1,0],[0,1]]);\n\n( Rationals^4 )\n\n\nEspacio vectorial\n\n\nAplicación\n\n\n\nImage(f);\n\nEspacio vectorial\n\n\n\nBasis(Image(f));\n\n[ [ 1, 2 ], [ 0, 1 ] ]\n\n\n\nBasis(Kernel(f));\n\n[ [ 1, -1/2, 1/2, 0 ], [ 0, 1, -3, -4 ] ]\n\n\nY teorema de isomorfía al canto…\n\nV1/Kernel(f)=Image(f);\n\ntrue\n\n\nTambién podemos usar notación matricial.\n\ng:=LeftModuleHomomorphismByMatrix(Basis(V1),[[1,0],[0,1],[1,1],[-1,1]], Basis(V2));\n\nAplicación\n\n\n\nImage(g,[1,2,3,4]);\n\n[ 0, 9 ]\n\n\n\nIsInjective(g);\n\nfalse\n\n\n\nIsSurjective(g);\n\ntrue",
    "crumbs": [
      "Matrices y espacios vectoriales"
    ]
  },
  {
    "objectID": "7 Matrices-espacios-vectoriales.html#diagonalización",
    "href": "7 Matrices-espacios-vectoriales.html#diagonalización",
    "title": "Matrices y espacios vectoriales",
    "section": "Diagonalización",
    "text": "Diagonalización\nVeamos cómo calcular el polinomio característico y sus ceros.\n\na:=[[1,0,1],[3,1,0],[0,1,0]]*One(GF(7));\n\n[ [ ZmodnZObj(1,7), ZmodnZObj(0,7), ZmodnZObj(1,7) ], [ ZmodnZObj(3,7), ZmodnZObj(1,7), ZmodnZObj(0,7) ], [ ZmodnZObj(0,7), ZmodnZObj(1,7), ZmodnZObj(0,7) ] ]\n\n\n\np:=CharacteristicPolynomial(a);\n\nx_1^3+ZmodnZObj(5,7)*x_1^2+x_1+ZmodnZObj(4,7)\n\n\n\nrs:=RootsOfPolynomial(p);\n\n[ ZmodnZObj(6,7), ZmodnZObj(5,7), ZmodnZObj(5,7) ]\n\n\nComprobemos si a es diagonalizable, para ello calculamos sus subespacios propios.\n\nList(Set(rs),r-&gt;NullspaceMat(TransposedMat(a-r*a^0)));\n\n[ [ [ ZmodnZObj(3,7), ZmodnZObj(6,7), ZmodnZObj(1,7) ] ], [ [ ZmodnZObj(2,7), ZmodnZObj(5,7), ZmodnZObj(1,7) ] ] ]\n\n\nComo vemos, el elemento \\(5\\in \\mathbb{Z}_7\\) es una raíz doble cuyo subespacio propio tiene dimensión uno, por lo que la matriz no es diagonalizable.\nVeamos otro ejemplo que sí es diagonalizable.\n\na:=[ [ -1, 0, -1 ], [ 0, -2, 0 ], [ -3, 0, 1 ] ];\n\n[ [ -1, 0, -1 ], [ 0, -2, 0 ], [ -3, 0, 1 ] ]\n\n\n\np:=CharacteristicPolynomial(a);\n\nx^3+2*x^2-4*x-8\n\n\n\nrs:=RootsOfPolynomial(p);\n\n[ 2, -2, -2 ]\n\n\n\nsp:=List(Set(rs),r-&gt;NullspaceMat(TransposedMat(a-r*a^0)));\n\n[ [ [ 0, 1, 0 ], [ 1, 0, 1 ] ], [ [ -1/3, 0, 1 ] ] ]\n\n\n\nP:=TransposedMat(Concatenation(sp));\n\n[ [ 0, 1, -1/3 ], [ 1, 0, 0 ], [ 0, 1, 1 ] ]\n\n\n\nP^(-1)*a*P;\n\n[ [ -2, 0, 0 ], [ 0, -2, 0 ], [ 0, 0, 2 ] ]",
    "crumbs": [
      "Matrices y espacios vectoriales"
    ]
  },
  {
    "objectID": "8 Visualizacion en jupyter y gap.html",
    "href": "8 Visualizacion en jupyter y gap.html",
    "title": "Algunos ejemplos de visualización en GAP",
    "section": "",
    "text": "Podemos crear funciones en GAP cuya salida sea una cadena de caracteres en dot (véase graphviz). Luego, podemos pasar esa salida a JupyterSplashDot.\n\nRelToDotNS:=function(uni, rel,labels)\n\n  local r, output, out, i, str;\n\n  str:=function(s)\n    return Concatenation(\"\\\"\",String(s),\"\\\"\");\n  end;\n\n  out:=\"\";\n  output:=OutputTextString(out,true);\n  AppendTo(output,\"graph  NSGraph{\");\n  for i in [1..Length(uni)] do\n    AppendTo(output,i,\" [label=\",str(labels[i]),\"];\");\n  od;\n  for r in rel do\n    AppendTo(output,Position(uni,r[1]),\" -- \",Position(uni,r[2]),\";\");\n  od;\n  AppendTo(output,\"}\");\n  CloseStream(output);\n  return out;\nend;\n\nfunction( uni, rel, labels ) ... end\n\n\nPara dibujar diagramas de Hasse, eliminamos la reflexividad y las relaciones que se deducen de otras por transitividad.\n\nhasse:=function(dom,rel)\n    local out;\n    \n    out:=Filtered(rel, p-&gt; p[1]=p[2] or ForAny(Difference(dom,p), x-&gt;([p[1],x] in rel) and ([x,p[2]] in rel)));\n    \n    return Difference(rel,out);\nend;\n\nfunction( dom, rel ) ... end\n\n\nCon esto, como ejemplo, vamos a dibujar el retículo de subespacios de \\(\\mathbb{Z}_5^2\\).\n\nInstallMethod(ViewString, [IsVectorSpace], function(v) return(\"Vector space\"); end);\n\n\nsz:= Subspaces(GF(5)^2);;\nun:=List(sz);;\nrels:=Filtered(Cartesian(un,un),p-&gt;IsSubspace(p[1],p[2]));;\nh:=hasse(un,rels);;\nlab:=List(sz,w-&gt;List(Basis(w),x-&gt;List(x,Int)));;\nJupyterSplashDot(RelToDotNS(un,h,lab));\n\n\n\n\n\n\n\n\nTambién podemos dibujar el retículo de divisores de un entero.\n\nun:=DivisorsInt(60);;\nrels:=Filtered(Cartesian(un,un),p-&gt;p[1] mod p[2]=0);;\nh:=hasse(un,rels);;\nJupyterSplashDot(RelToDotNS(un,h,un));",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "8 Visualizacion en jupyter y gap.html#usando-lenguage-dot",
    "href": "8 Visualizacion en jupyter y gap.html#usando-lenguage-dot",
    "title": "Algunos ejemplos de visualización en GAP",
    "section": "",
    "text": "Podemos crear funciones en GAP cuya salida sea una cadena de caracteres en dot (véase graphviz). Luego, podemos pasar esa salida a JupyterSplashDot.\n\nRelToDotNS:=function(uni, rel,labels)\n\n  local r, output, out, i, str;\n\n  str:=function(s)\n    return Concatenation(\"\\\"\",String(s),\"\\\"\");\n  end;\n\n  out:=\"\";\n  output:=OutputTextString(out,true);\n  AppendTo(output,\"graph  NSGraph{\");\n  for i in [1..Length(uni)] do\n    AppendTo(output,i,\" [label=\",str(labels[i]),\"];\");\n  od;\n  for r in rel do\n    AppendTo(output,Position(uni,r[1]),\" -- \",Position(uni,r[2]),\";\");\n  od;\n  AppendTo(output,\"}\");\n  CloseStream(output);\n  return out;\nend;\n\nfunction( uni, rel, labels ) ... end\n\n\nPara dibujar diagramas de Hasse, eliminamos la reflexividad y las relaciones que se deducen de otras por transitividad.\n\nhasse:=function(dom,rel)\n    local out;\n    \n    out:=Filtered(rel, p-&gt; p[1]=p[2] or ForAny(Difference(dom,p), x-&gt;([p[1],x] in rel) and ([x,p[2]] in rel)));\n    \n    return Difference(rel,out);\nend;\n\nfunction( dom, rel ) ... end\n\n\nCon esto, como ejemplo, vamos a dibujar el retículo de subespacios de \\(\\mathbb{Z}_5^2\\).\n\nInstallMethod(ViewString, [IsVectorSpace], function(v) return(\"Vector space\"); end);\n\n\nsz:= Subspaces(GF(5)^2);;\nun:=List(sz);;\nrels:=Filtered(Cartesian(un,un),p-&gt;IsSubspace(p[1],p[2]));;\nh:=hasse(un,rels);;\nlab:=List(sz,w-&gt;List(Basis(w),x-&gt;List(x,Int)));;\nJupyterSplashDot(RelToDotNS(un,h,lab));\n\n\n\n\n\n\n\n\nTambién podemos dibujar el retículo de divisores de un entero.\n\nun:=DivisorsInt(60);;\nrels:=Filtered(Cartesian(un,un),p-&gt;p[1] mod p[2]=0);;\nh:=hasse(un,rels);;\nJupyterSplashDot(RelToDotNS(un,h,un));",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "8 Visualizacion en jupyter y gap.html#jupyterviz",
    "href": "8 Visualizacion en jupyter y gap.html#jupyterviz",
    "title": "Algunos ejemplos de visualización en GAP",
    "section": "jupyterviz",
    "text": "jupyterviz\nUna de las posibilidades es utilizar jupyterviz. En este bloc usamos la versión 1.3.\n\nLoadPackage(\"jupyterviz\");\n\ntrue\n\n\nVamos a representar el número de formas distintas en las que podemos comprar \\(n\\) nuggets de pollo si las cajas disponibles son de 6, 9 y 10 nuggets, respectivamente.\n\nPlot([20..50], x-&gt;Length(RestrictedPartitions(x,[6,9,10])), \n rec(\ntitle := \"Número de formas distintas en las que se pueden comprar nuggets\",\n          xaxis := \"n\",\nyaxis := \"número de expresiones de n\", type:=\"bar\"\n      ));\n\n\n\n\nLe vamos a añadir ahora una segunda gráfica que represente el mínimo número de cajas necesarias para comprar \\(n\\) nuggets.\n\nl:=[6,9,10];;\nPlot([[50..100], x-&gt;Length(RestrictedPartitions(x,l)), \n rec(\ntitle := \"Número de formas en las que se pueden comprar nuggets\",\n          xaxis := \"n\",\nyaxis := \"número de expresiones de n\", type:=\"bar\", name:=\"posibilidades\"\n)], \n[[50..100], x-&gt;Minimum(List(RestrictedPartitions(x,l),Length)), \n rec(\ntype:=\"line\", title:=\"Mínimo número de cajas necesarias\", name:=\"min # cajas\",\n)]\n);\n\n\n\n\nPonemos un tipo de caja más, con 13 nuggets.\n\nl:=[6,9,10,13];;\nPlot([[50..100], x-&gt;Length(RestrictedPartitions(x,l)), \n rec(\ntitle := \"Número de formas en las que se pueden comprar nuggets\",\n          xaxis := \"n\",\nyaxis := \"número de expresiones de n\", type:=\"bar\", name:=\"posibilidades\"\n)], \n[[50..100], x-&gt;Minimum(List(RestrictedPartitions(x,l),Length)), \n rec(\ntype:=\"line\", title:=\"Mínimo número de cajas necesarias\", name:=\"min # cajas\"\n)]\n);\n\n\n\n\nVeamos ahora la proporción que tiene cada número posible de cajas en todas las formas posibles que tenemos de comprar 100 nuggets. En este ejemplo 100 se puede conseguir con un mínimo de 12 cajas, y un máximo de 25. El número de cajas más frecuente entre todas las posibilidades es 17.\n\np:=RestrictedPartitions(100,[4,6,9]);;\nls:=List(p,Length);;\nPlot(Set(ls),x-&gt;Length(Filtered(ls,l-&gt;l=x)), rec(type:=\"pie\", height:=500, \ntitle:=\"Número de formas de comprar 100 nuggets clasificadas por el número de cajas necesarias\"));\n\n\n\n\nAhora representamos la misma idea con un gráfico de frecuencias.\n\nPlot(Set(ls),x-&gt;Length(Filtered(ls,l-&gt;l=x)), rec(xaxis:=\"Número de cajas necesarias para 100 nuggets\", \nyaxis:=\"Número de posibilidades\"));\n\n\n\n\nTambién podemos dibujar grafos. El siguiente grafo representa las relaciones de divisibilidad (quitamos las que se deducen por transitividad y reflexividad con hasse).\n\nd:=DivisorsInt(24);;\nPlotGraph(d, hasse(d,Filtered(Cartesian(d,d), p-&gt;p[2] mod p[1]=0)), \n    rec(directed:=true, layout:=\"circle\", arrowscale:=2)\n);",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "8 Visualizacion en jupyter y gap.html#francy",
    "href": "8 Visualizacion en jupyter y gap.html#francy",
    "title": "Algunos ejemplos de visualización en GAP",
    "section": "francy",
    "text": "francy\nOtra posibilidad es utilizar francy que además tiene callbacks. Podemos crear visualizaciones interactivas. En el ejemplo que mostramos abajo, se crea el retículo de divisores de un entero. Cuando el ratón pasa por un nodo escribirá su factorización, y cuando hagamos click en él mostrará un mensaje dando esa información.\n\nLoadPackage(\"francy\");\n\ntrue\n\n\n\npinta_divisores:=function(x)\n    local hasse, muestrafacts,graphHasse,d, ds, canvas, message, c, i ,r, n;\n    hasse:=function(rel)\n      local dom, out;\n      dom:=Flat(rel);\n      out:=Filtered(rel, p-&gt; ForAny(dom, x-&gt;([p[1],x] in rel) and ([x,p[2]] in rel)));\n      return Difference(rel,out);\n    end;\n\n\n    muestrafacts:=function(x)\n        message := FrancyMessage(Concatenation(String(x), \" factoriza como \"), \n            String(Factors(x)));\n        SetFrancyId(message, Concatenation(\"message-for-\", String(x)));\n        Add(canvas, message);\n        return Draw(canvas);\n    end;\n\n  \n    graphHasse := Graph(GraphType.UNDIRECTED);\n    #SetSimulation(graphHasse,true);\n    #SetDrag(graphHasse,true);\n    d:=DivisorsInt(x);\n    n:=Length(d);\n    c:=Cartesian([1..n],[1..n]);\n    c:=Filtered(c, p-&gt; p[2]&lt;&gt;p[1]);\n    c:=Filtered(c, p-&gt; d[p[2]] mod d[p[1]]=0);\n    c:=hasse(c);\n    ds:=[];\n    for i in [1..n] do\n        ds[i]:=Shape(ShapeType!.CIRCLE, String(d[i]));\n        SetLayer(ds[i],-d[i]);\n        Add(ds[i],Callback(muestrafacts,[d[i]]));\n        Add(ds[i],FrancyMessage(String(Factors(d[i]))));\n        Add(graphHasse,ds[i]);\n    od;\n    for r in c do\n        Add(graphHasse,Link(ds[r[1]],ds[r[2]]));\n    od;\n    canvas:=Canvas(\"Divisores\");\n    Add(canvas,graphHasse);\n    return Draw(canvas);    \nend;\n\nfunction( x ) ... end\n\n\n\npinta_divisores(12);\n\nUnable to display output for mime type(s): application/vnd.francy+json",
    "crumbs": [
      "Visualización"
    ]
  },
  {
    "objectID": "4 Combinatoria.html",
    "href": "4 Combinatoria.html",
    "title": "Combinatoria",
    "section": "",
    "text": "Si queremos calcular el conjunto de secuencias de \\(r\\) elementos tomados a partir de \\(n\\) elementos iniciales, podemos Arrangements. También podemos usar NrArrangements para conocer cuántas hay.\nArrangements([1,2,3],2);\n\n[ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ]\nNrArrangements([1..3],2);\n\n6\nArrangements permite repeticiones el el conjunto de elementos del que escogemos las secuencias.\nArrangements([1,2,2,3],2);\n\n[ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ]\nLas permutaciones de una lista se pueden construir con Permutations.\nPermutationsList([1..3]);\n\n[ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ], [ 3, 2, 1 ] ]\nSi lo que queremos son \\(n\\)-uplas, usamos Tuples.\nTuples([1..3],2);\n\n[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ]\nCuando lo que queremos son conjuntos en vez de secuencias, usamos combinaciones.\nCombinations([1..3],2);\n\n[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]\nNrCombinations([1..3],2);\n\n3\nBinomial(3,2);\n\n3\nEl comando PartitionsSet se utiliza para calcular el número de particiones de un conjunto dado.\nPartitionsSet([1..3]);\n\n[ [ [ 1 ], [ 2 ], [ 3 ] ], [ [ 1 ], [ 2, 3 ] ], [ [ 1, 2 ], [ 3 ] ], [ [ 1, 2, 3 ] ], [ [ 1, 3 ], [ 2 ] ] ]\nSi especificamos un segundo argumento, calcula el número de particiones con cardinal exactamente ese argumento.\nPartitionsSet([1..5],2);\n\n[ [ [ 1 ], [ 2, 3, 4, 5 ] ], [ [ 1, 2 ], [ 3, 4, 5 ] ], [ [ 1, 2, 3 ], [ 4, 5 ] ], [ [ 1, 2, 3, 4 ], [ 5 ] ], [ [ 1, 2, 3, 5 ], [ 4 ] ], [ [ 1, 2, 4 ], [ 3, 5 ] ], [ [ 1, 2, 4, 5 ], [ 3 ] ], [ [ 1, 2, 5 ], [ 3, 4 ] ], [ [ 1, 3 ], [ 2, 4, 5 ] ], [ [ 1, 3, 4 ], [ 2, 5 ] ], [ [ 1, 3, 4, 5 ], [ 2 ] ], [ [ 1, 3, 5 ], [ 2, 4 ] ], [ [ 1, 4 ], [ 2, 3, 5 ] ], [ [ 1, 4, 5 ], [ 2, 3 ] ], [ [ 1, 5 ], [ 2, 3, 4 ] ] ]\nNrPartitionsSet([1..5],2);\n\n15\nEl comando Partitions devuelve el número de formas posibles de sumar el argumento entero que pasemos.\nPartitions(5);\n\n[ [ 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1 ], [ 2, 2, 1 ], [ 3, 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5 ] ]\nPodemos calcular cuántas de estas tienen una longitud determinada.\nPartitions(5,2);\n\n[ [ 3, 2 ], [ 4, 1 ] ]\nSi buscamos particiones ordenadas, hacemos lo siguiente\nOrderedPartitions(5);\n\n[ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 1, 3 ], [ 1, 2, 1, 1 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 1, 4 ], [ 2, 1, 1, 1 ], [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 3 ], [ 3, 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5 ] ]\nAsí las soluciones enteras positivas de \\(x+y=5\\) vienen dadas por\nOrderedPartitions(5,2);\n\n[ [ 1, 4 ], [ 2, 3 ], [ 3, 2 ], [ 4, 1 ] ]",
    "crumbs": [
      "Combinatoria"
    ]
  },
  {
    "objectID": "4 Combinatoria.html#iteradores",
    "href": "4 Combinatoria.html#iteradores",
    "title": "Combinatoria",
    "section": "Iteradores",
    "text": "Iteradores\nMuchas de estas funciones tienen una versión con iteradores, para no tener que generarlas todas y almacenarlas en memoria.\nIteratorOfCombinations, IteratorOfPartitions, IteratorOfTuples.\n\nInstallMethod(ViewString,[IsIterator], \nfunction(l) \n    return \"Iterator\"; \nend);\n\n\nl:=IteratorOfCombinations([1..4],2);\nfor i in l do\nPrint(i,\" suman \",Sum(i),\"\\n\");\nod;\n\n[ 1, 2 ] suman 3\n[ 1, 3 ] suman 4\n[ 2, 3 ] suman 5\n[ 1, 4 ] suman 5\n[ 2, 4 ] suman 6\n[ 3, 4 ] suman 7\n\n\nIterator",
    "crumbs": [
      "Combinatoria"
    ]
  },
  {
    "objectID": "5 Conjuntos relaciones funciones.html",
    "href": "5 Conjuntos relaciones funciones.html",
    "title": "Conjuntos, relaciones y funciones",
    "section": "",
    "text": "Como ya hemos visto, las listas en gap se denotan como una secuencia entre corchetes. La función Set convierte una lista en un conjunto, y por tanto, entre otras cosas, elimina instancias repetidas de elementos. Las operaciones básicas de conjuntos son las siguientes.\n\na:=Set([1,2,3]);\n\n[ 1, 2, 3 ]\n\n\n\nb:=Set([2,4,5,6]);\n\n[ 2, 4, 5, 6 ]\n\n\n\nUnion(a,b);\n\n[ 1, 2, 3, 4, 5, 6 ]\n\n\n\nIntersection(a,b);\n\n[ 2 ]\n\n\n\nDifference(a,b);\n\n[ 1, 3 ]\n\n\n\nDifference(b,a);\n\n[ 4, 5, 6 ]\n\n\nUna relación de equivalencia se puede definir de varias formas. Veamos algunas de ellas. Lo primero que tenemos que declarar es un dominio en el que trabajar.\n\na:=Domain(Set([1..20]));\n\n&lt;object&gt;\n\n\nPodemos entonces definir por ejemplo una relación usando una partición de dicho dominio.\n\nr:=EquivalenceRelationByPartition(a,[[1..10],[11..20]]);\n\n&lt;object&gt;\n\n\nY luego ver cuáles son las clases de equivalencia, o comprobar si dos elementos están o no relacionados.\n\nList(EquivalenceClasses(r),Elements);\n\n[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], [ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ] ]\n\n\n\nEquivalenceClassOfElement(r,2)=EquivalenceClassOfElement(r,3);\n\ntrue\n\n\nTambién podemos definir una relación de equivalencia como la menor que contenga un conjunto de parejas.\n\nr:=EquivalenceRelationByPairs(a,[[1,2],[3,4]]);\n\n&lt;object&gt;\n\n\n\nList(EquivalenceClasses(r),Elements);\n\n[ [ 1, 2 ], [ 3, 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], [ 10 ], [ 11 ], [ 12 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], [ 19 ], [ 20 ] ]\n\n\n\nEquivalenceClassOfElement(r,2)=EquivalenceClassOfElement(r,3);\n\nfalse\n\n\nLas funciones también se pueden definir usando reglas. Veamos algunos ejemplos.\n\na:=Domain([-2..2]);\n\n&lt;object&gt;\n\n\n\nb:=Domain([-5..5]);\n\n&lt;object&gt;\n\n\n\n f:=MappingByFunction(a,b,x-&gt;x^2);\n\n&lt;object&gt;\n\n\n\nIsInjective(f);\n\nfalse\n\n\n\nIsSurjective(f);\n\nfalse\n\n\nCalcular la imagen de f, o bien la de un subconjunto del dominio.\n\nImage(f);\n\n[ 0, 1, 4 ]\n\n\n\nImage(f,1);\n\n1\n\n\n\nImage(f,[0,2]);\n\n[ 0, 4 ]\n\n\nY lo mismo con preimágenes o imágenes inversas.\n\nPreImages(f,2);\n\n[  ]\n\n\n\nPreImages(f,1);\n\n[ -1, 1 ]\n\n\n\nPreImages(f,[1,4]);\n\n[ -2, -1, 1, 2 ]",
    "crumbs": [
      "Conjuntos, relaciones y funciones"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html",
    "href": "2 Aritmetica entera y modular.html",
    "title": "Aritmética entera y modular",
    "section": "",
    "text": "En este bloc mostramos los comandos básicos para trabajar con aritmética entera modular.",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html#cociente-y-resto",
    "href": "2 Aritmetica entera y modular.html#cociente-y-resto",
    "title": "Aritmética entera y modular",
    "section": "Cociente y resto",
    "text": "Cociente y resto\nDados dos enteros \\(a\\) y \\(b\\), el resto de dividir \\(a\\) entre \\(b\\) se puede calcular usando el comando mod.\n\n-3 mod 5;\n\n2\n\n\nAsí el cociente se puede calcular como sigue\n\n(-3-(-3 mod 5))/5;\n\n-1\n\n\nEn cualquier dominio euclídeo también se puede utilizar QuotientRemainder.\n\nQuotientRemainder(Integers,-3,5);\n\n[ 0, -3 ]\n\n\nSi en gap escribimos \\(-3/5\\), el resultado es un racional, y si usamos el comando Int, obtenemos la parte entera de ese racional.\n\nInt(-3/5);\n\n0",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html#máximo-común-divisor-y-mínimo-común-múltiplo.-coeficientes-de-bézout",
    "href": "2 Aritmetica entera y modular.html#máximo-común-divisor-y-mínimo-común-múltiplo.-coeficientes-de-bézout",
    "title": "Aritmética entera y modular",
    "section": "Máximo común divisor y mínimo común múltiplo. Coeficientes de Bézout",
    "text": "Máximo común divisor y mínimo común múltiplo. Coeficientes de Bézout\nEl máximo común divisor de dos enteros (o más) puede ser calculado con el comando Gcd, y su mínimo común múltiplo con el comando Lcm.\n\nGcd(3,-5);\n\n1\n\n\n\nLcm(3,-15);\n\n15\n\n\nSi queremos conseguir los coeficientes de Bézout, podemos usar el comando GcdRepresentation (entre las muchas posibilidades que da gap para esto).\n\nl:=GcdRepresentation(3,-5);\n\n[ 2, 1 ]\n\n\n\nl*[3,-5];\n\n1\n\n\n\nGcdRepresentation(10,15,18);\n\n[ 7, -7, 2 ]\n\n\n\nEcuaciones diofánticas lineales\nComo ya sabemos, una vez resuelto el problema de encontrar los coeficientes de Bézout de un máximo común divisor de dos enteros, tenemos también solución para resolver una ecuación diofántica. Lo único que tenemos que comprobar es si el término independiente es divisible por el máximo común divisor de los coeficientes, y luego multiplicar los coeficientes de Bézout por el factor apropiado para conseguir una solución particular.\nSi queremos resolver \\(10x+25 y= 45\\), hacemos lo siguiente.\n\nGcd(10,25);\n\n5\n\n\nQue divide a \\(45\\). Luego una solución se obtiene fácilmente usando los coeficientes de Bézout.\n\ns:=GcdRepresentation(10,25)*45/Gcd(10,25);\n\n[ -18, 9 ]\n\n\nPodemos ver que el resultado es el correcto.\n\nl*[10,25];\n\n45",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html#factorizaciones-y-primos",
    "href": "2 Aritmetica entera y modular.html#factorizaciones-y-primos",
    "title": "Aritmética entera y modular",
    "section": "Factorizaciones y primos",
    "text": "Factorizaciones y primos\nPara factorizar un entero en producto de primos podemos usar el comando Factors.\n\nFactors(100);\n\n[ 2, 2, 5, 5 ]\n\n\nTambién podemos saber si un número es primo usando el comando IsPrime.\n\nIsPrime(10);\n\nfalse\n\n\nPrimes es una lista que contiene los primos menores que mil.\n\nLength(Primes);\n\n168\n\n\n\nPrimes[168];\n\n997\n\n\nLos primeros \\(40\\) primos:\n\nPrimes{[1..40]};\n\n[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173 ]\n\n\nComo ya vimos en en el bloc de primeros pasos, podemos usar Filtered para obtener primos en un rango determinado.\n\nFiltered([1000..10000], IsPrime);\n\n[ 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973 ]",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html#congruencias",
    "href": "2 Aritmetica entera y modular.html#congruencias",
    "title": "Aritmética entera y modular",
    "section": "Congruencias",
    "text": "Congruencias\nPara resolver una ecuación en recurrencias podemos usar GcdRepresentation como hicimos arriba con una ecuación diofántica lineal.\nSi lo que queremos es resolver un sistema de congruencias de la forma [\n\\[\\begin{array}{l}\nx\\equiv a_1\\bmod m_1,\\\\\n\\dots\\\\\nx\\equiv a_n\\bmod m_n,\n\\end{array}\\]\n] entonces podemos usar el comando ChineseRem, cuyo primer argumento es la lista de módulos y el segundo una lista (con la misma longitud) de residuos.\nAsí, para resolver [\n\\[\\begin{array}{l}\nx\\equiv 3\\bmod 14,\\\\\nx\\equiv 7 \\bmod 16,\n\\end{array}\\]\n] hacemos lo siguiente.\n\nChineseRem([14,16],[3,7]);\n\n87\n\n\nPodemos comprobar el resultado:\n\nList([14,16], x-&gt; 87 mod x);\n\n[ 3, 7 ]",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "2 Aritmetica entera y modular.html#anillos-mathbbz_n",
    "href": "2 Aritmetica entera y modular.html#anillos-mathbbz_n",
    "title": "Aritmética entera y modular",
    "section": "Anillos \\(\\mathbb{Z}_n\\)",
    "text": "Anillos \\(\\mathbb{Z}_n\\)\nLa función ZmodnZ nos permite definir en gap el anillo de enteros módulo el argumento entero que le pasemos.\n\nInstallMethod(ViewString,[IsZmodnZObj],String);\n\n\nA:=ZmodnZ(10);\n\n&lt;monoid&gt;\n\n\nEl uno de un anillo (el elemento neutro del producto) se calcula con el comando One.\n\n uno:=One(A);\n\nZmodnZObj(1,10)\n\n\nPodemos hacer operaciones elementales en ese anillo, como calcular inversos, sumar elementos… Usamos Int para que lo represente como un entero.\n\nInt(1/(3*uno));\n\n7\n\n\n\nInt(2*uno+6/3*uno);\n\n4\n\n\nSi un elemento no tiene inverso, devuelve fail.\n\n1/2*uno;\n\nfail\n\n\nPodemos usar también Inverse.\n\nInt(Inverse(3*uno));\n\n7\n\n\nY extraer así el conjunto de unidades de \\({\\mathbb Z}_{10}\\).\n\nFiltered([1..9],n-&gt;Inverse(n*uno)&lt;&gt;fail);\n\n[ 1, 3, 7, 9 ]\n\n\nQue también se puede obtener con PrimeResidues.\n\nPrimeResidues(10);\n\n[ 1, 3, 7, 9 ]\n\n\nO bien con Units:\n\nU:=Units(A);\n\n&lt;group of size 4 with 1 generators&gt;\n\n\nPodemos ver los elementos de este grupo con Elements o con List.\n\nElements(U);\n\n[ ZmodnZObj(1,10), ZmodnZObj(3,10), ZmodnZObj(7,10), ZmodnZObj(9,10) ]\n\n\n\nList(Units(A), Int);\n\n[ 1, 3, 7, 9 ]\n\n\n\n1/Elements(U)[2];\n\nZmodnZObj(7,10)\n\n\nLa función \\(\\varphi\\) de Euler (función tociente) se expresa como Phi en gap.\n\nPhi(10);\n\n4\n\n\nEs más podemos usar el filtro IsField para ver is un anillo es un cuerpo.\n\nIsField(A);\n\nfalse\n\n\n\nIsField(ZmodnZ(5));\n\ntrue",
    "crumbs": [
      "Aritmética entera y modular"
    ]
  },
  {
    "objectID": "9 Creando nuevos objetos.html",
    "href": "9 Creando nuevos objetos.html",
    "title": "Ejemplo de creación de un nuevo tipo de objeto",
    "section": "",
    "text": "En gap todo son objetos. Podemos crear nuestros propios objetos con sus atributos, propiedades y métodos.\nVamos a ver en este bloc un ejemplo de un objeto que represente un número racional. Esto ya existe en gap pero lo hacemos desde cero para ilustrar cómo se define una nueva clase.\nTodas las deficiones están en ejemplo-objeto.g, vamos a ir comentanto poco a poco lo que contiene este fichero.\nRead(\"ejemplo-objeto.g\");",
    "crumbs": [
      "Objetos"
    ]
  },
  {
    "objectID": "9 Creando nuevos objetos.html#creando-el-tipo-de-representación-interna-y-la-categoría-del-objeto",
    "href": "9 Creando nuevos objetos.html#creando-el-tipo-de-representación-interna-y-la-categoría-del-objeto",
    "title": "Ejemplo de creación de un nuevo tipo de objeto",
    "section": "Creando el tipo de representación interna y la categoría del objeto",
    "text": "Creando el tipo de representación interna y la categoría del objeto\nVamos a representar una fracción mediante su numerador y denominador. Es por ello que vamos a usar una representación nueva, EsFraccionRep, del tipo IsAttributeStoringRep, pues tendremos estos dos atributos almacenados en un racional. A la categoría (clase) le vamos a llamar EsFraccion y va a ser representable mediante EsFraccionRep y es una subcategoría de IsAdditiveElement, pues luego vamos a definir una función que sume fracciones. Por último definimos un nuevo tipo de dato que llamaremos TipoFraccion, que estará en la familia FamiliaFracciones.\nDeclareRepresentation(\"EsFraccionRep\", IsAttributeStoringRep, []);\nDeclareCategory( \"EsFraccion\", EsFraccionRep and IsAdditiveElement);\nTipoFraccion:=NewType(NewFamily(\"FamiliaFracciones\"), EsFraccion);",
    "crumbs": [
      "Objetos"
    ]
  },
  {
    "objectID": "9 Creando nuevos objetos.html#declarando-los-atributos-propiedades-y-métodos",
    "href": "9 Creando nuevos objetos.html#declarando-los-atributos-propiedades-y-métodos",
    "title": "Ejemplo de creación de un nuevo tipo de objeto",
    "section": "Declarando los atributos, propiedades y métodos",
    "text": "Declarando los atributos, propiedades y métodos\nVamos a tener como atributos el numerador y el denominador.\nDeclareAttribute(\"Numerador\", EsFraccion);\nDeclareAttribute(\"Denominador\", EsFraccion);\nComo operaciones vamos a definir una simplificación y una suma (que podemos hacerlo al pertenecer nuestra categeoría a la de los elementos con suma). La suma no hace falta declararla, sólo tendremos que definir después un método apropiado.\nDeclareOperation(\"Simplifica\", [EsFraccion]);\nVamos además a definir dos propiedades: ser positivo y ser no negativo.\nDeclareProperty(\"EsPositivo\", EsFraccion);\nDeclareProperty(\"EsNoNegativo\", EsFraccion);",
    "crumbs": [
      "Objetos"
    ]
  },
  {
    "objectID": "9 Creando nuevos objetos.html#creando-un-objeto-de-tipo-esfraccion",
    "href": "9 Creando nuevos objetos.html#creando-un-objeto-de-tipo-esfraccion",
    "title": "Ejemplo de creación de un nuevo tipo de objeto",
    "section": "Creando un objeto de tipo EsFraccion",
    "text": "Creando un objeto de tipo EsFraccion\nVamos a dar una función que, a partir de dos enteros, nos devuelva una fracción.\nFraccion:=function(a,b)\n    local r;\n    if not(IsInt(a)) then \n        Error(\"El primer argumento debe ser un entero\");\n    fi;\n\n    if not(IsInt(b)) or (b=0) then \n        Error(\"El segundo argumento debe ser un entero no nulo\");\n    fi;\n    \n    r:=Objectify(TipoFraccion, rec());\n    SetNumerador(r,a);\n    SetDenominador(r,b);\n    return r;\nend;\n\nr:=Fraccion(2,4);\n\n2 / 4\n\n\n\nTypeObj(r);\n\n&lt;Type: (FamiliaFracciones, [ IsComponentObjectRep, IsAttributeStoringRep, IsExtAElement, ... ]), data: fail,&gt;\n\n\n\nEsFraccion(r);\n\ntrue\n\n\nComo podemos observar, al crear r devuelve 2 / 4. Ésta es la forma en la que le hemos dicho que represente r, y lo que está devolviendo es el objeto r. Para ello hemos definido un método ViewString para fracciones.\nInstallMethod(ViewString, \"mostrar fracciones\", [EsFraccion],\n    function(x)\n        return Concatenation(String(Numerador(x)),\" / \",String(Denominador(x)));\nend);\nPara la salida de Print podemos definir String.\nInstallMethod(String, \"fracciones a cadenas\", [EsFraccion],\n    function(x)\n        return Concatenation(String(Numerador(x)),\"/\",String(Denominador(x)));\nend);\n\nPrint(r);\n\n2/4\n\n\nComo la función Fraccion establece los atributos denominador y numerador, ya podemos pedirle a gap que nos los diga.\n\nNumerador(r);\n\n2\n\n\n\nDenominador(r);\n\n4\n\n\nTambién hemos definido otra forma “más bonita” de representar r. Para ello hemos definido el método Display para fracciones.\nInstallMethod(Display, \"mostrar racionales\", [EsFraccion],\n    function(x)\n        local l,s,i;\n\n        l:=Maximum(Length(String(Numerador(x))),Length(String(Denominador(x))));\n        s:=\"\";\n        for i in [1..l] do\n            Append(s,\"-\");\n        od;\n        Print(Numerador(x),\"\\n\");\n        Print(s,\"\\n\");\n        Print(Denominador(x),\"\\n\");\n        return;\nend);\n\nDisplay(r);\n\n2\n-\n4\n\n\nLas propiedades ser positivo o no negativo se pueden definir como sigue.\nInstallMethod(EsPositivo, \"es positivo para fracciones\", [EsFraccion],\n    function(x)\n        return Numerador(x)*Denominador(x)&gt;0;\nend);\n\nInstallMethod(EsNoNegativo, \"es positivo para fracciones\", [EsFraccion],\n    function(x)\n        return Numerador(x)*Denominador(x)&gt;=0;\nend);\nEl hecho de que una fracción sea positiva implica que ésta es no negativa. Podemos por tanto indicarle esto a gap para que siempre que sepa que una fracción es positiva y le preguntemos si es negativa, no tenga que hacer ningún cálculo intermedio.\nInstallTrueMethod(EsNoNegativo, EsPositivo);\n\nTraceMethods([EsNoNegativo]);\n\n\nr:=Fraccion(2,4);\n\n2 / 4\n\n\n\nEsNoNegativo(r);\n\n#I  EsNoNegativo: es positivo para fracciones at ejemplo-objeto.g:31\n\n\ntrue\n\n\nComo EsNoNegativo es una propiedad de r, si volvemos a preguntar si es no negativo no hará ninguna llamada a ninguna función, pues ya lo tiene almacenado.\n\nEsNoNegativo(r);\n\ntrue\n\n\nLo mismo ocurre si primero hemos preguntado si es positivo. Le hemos dicho que eso implica ser no negativo.\n\nr:=Fraccion(2,4);\n\n2 / 4\n\n\n\nEsPositivo(r);\n\ntrue\n\n\n\nEsNoNegativo(r);\n\ntrue\n\n\n\nUntraceMethods([EsNoNegativo]);\n\nDefinamos ahora una función que devuelva la fracción simplificada de una fracción dada.\nInstallMethod(Simplifica, \"simplificación para fracciones\", [EsFraccion], \n    function(x)\n        local s, d;\n\n        d:=Gcd(Numerador(x),Denominador(x));\n        return Fraccion(Numerador(x)/d,Denominador(x)/d);\nend);\n\nSimplifica(r);\n\n1 / 2\n\n\n\nr;\n\n2 / 4\n\n\nLa igualdad de fracciones y la suma se pueden definir de la siguiente manera.\nInstallMethod(\\=, \"igualdad para fracciones\", [EsFraccion, EsFraccion],\n    function(x,y)\n        return Numerador(x)*Denominador(y)=Numerador(y)*Denominador(x); \nend);\n\nInstallMethod(\\+, \"suma de fracciones\", [EsFraccion, EsFraccion],\n    function(x,y)\n        return Simplifica(Fraccion(Numerador(x)*Denominador(y)+ Numerador(y)*Denominador(x),Denominador(x)*Denominador(y)));\nend);\n\nSimplifica(r)=r;\n\ntrue\n\n\n\nr+r;\n\n1 / 1",
    "crumbs": [
      "Objetos"
    ]
  },
  {
    "objectID": "6 Polinomios.html",
    "href": "6 Polinomios.html",
    "title": "Polinomios",
    "section": "",
    "text": "Para empezar a trabajar con polinomios, tenemos que especificar las variables y qué anillo de coeficientes vamos a considerar. gap por defecto expande las expresiones que introducimos.\nInstallMethod(ViewString,[IsPolynomial],String);\nPara definir una indeterminada, utilizamos Intederminate, indicando el nombre con el que se va a representar (en este caso x) y sobre qué anillo se va a definir esa indeterminada (en este caso el cuerpo de los racionales).\nx:=Indeterminate(Rationals,\"x\");\n\nx\nLa indeterminada se mostrará en la salida como “x”, y en nuestro caso hemos usado también ese nombre como identificador para poder operar con esa indeterminada.\ngap expandirá cualquier expresión polinomial que le pasemos.\n(x+1)*(x-1)^5;\n\nx^6-4*x^5+5*x^4-5*x^2+4*x-1\nSi queremos obtener una lista de los coeficientes de un polinomio en una variable, podemos usar lo siguiente.\nCoefficientsOfUnivariatePolynomial(x^3+x-1);\n\n[ -1, 1, 0, 1 ]\nY el coeficiente líder lo obtenemos con LeadingCoefficient.\nLeadingCoefficient(x^3+x-1);\n\n1\nDefinamos una función para encontrar el término líder de un polinomio respecto de una variable. En ella usamos funciones que son alternativa a las que acabamos de ver para más de una variable.\nterminolider:=function(p,x)\n    local grado;\n    grado:=DegreeIndeterminate(p,x);\n    return PolynomialCoefficientsOfPolynomial(p,x)[grado+1]*x^grado;\nend;\n\nfunction( p, x ) ... end\nterminolider(x^2+x-1,x);\n\nx^2\nterminolider(3*x^2+x-1,x);\n\n3*x^2\nLa función que hemos definido se puede utilizar con polinomios en más de una variable.\ny:=Indeterminate(Rationals,\"y\");\n\ny\nterminolider(y*x^2+y^4*x-1,x);\n\nx^2*y\nterminolider(y*x^2+y^4*x-1,y);\n\nx*y^4\nLeadingCoefficient(y*x^2+y^4*x-1);\n\n1\nPolynomialCoefficientsOfPolynomial(y*x^2+y^4*x-1,x);\n\n[ -1, y^4, y ]",
    "crumbs": [
      "Polinomios"
    ]
  },
  {
    "objectID": "6 Polinomios.html#división-de-polinomios",
    "href": "6 Polinomios.html#división-de-polinomios",
    "title": "Polinomios",
    "section": "División de polinomios",
    "text": "División de polinomios\nSi el anillo de coeficientes que consideramos es un cuerpo, entonces sabemos que el anillo de polinomios sobre una sola variable es un dominio euclídeo. Por tanto, podemos usar las funciones que ya conocemos para calcular el cociente y resto de una división.\n\nQuotientRemainder(x^3-x+1,2*x^2-3);\n\n[ 1/2*x, 1/2*x+1 ]\n\n\nSi nuestro anillo de polinomios no es un dominio euclídeo, entonces no podemos usar estas funciones.\n\nQuotientRemainder((x^3-x+1)*(y-1),y-1);\n\nError, no method found! For debugging hints type ?Recovery from NoMethodFound\nError, no 2nd choice method found for `QuotientRemainder' on 3 arguments at /home/pedro/lib/gap-4.12.2/lib/methsel2.g:249 called from\nQuotientRemainder( DefaultRing( [ r, m ] ), r, m ) at /home/pedro/lib/gap-4.12.2/lib/ring.gi:1092 called from\n&lt;function \"QuotientRemainder for two ring elements\"&gt;( &lt;arguments&gt; )\n called from read-eval loop at stream:1\n\n\nAhora bien, si que podemos usar la función Quotient que nos da el cociente, en caso de que éste pertenezca a nuestro anillo de polinomio, y fail en caso contrario.\n\nQuotient((x^3-x+1)*(y-1),y-1);\n\nx^3-x+1\n\n\nPodemos utilizar también /. En el caso en que el denominador divida al numerador, gap devolverá el cociente. En caso contrario, la salida será una función racional.\n\n(x^3-x+1)*(y-1)/(y-1);\n\nx^3-x+1\n\n\n\n(x^3-x+1)*(y-1)/(y-14);\n\n(x^3*y-x^3-x*y+x+y-1)/(y-14)",
    "crumbs": [
      "Polinomios"
    ]
  },
  {
    "objectID": "6 Polinomios.html#factorización-de-polinomios",
    "href": "6 Polinomios.html#factorización-de-polinomios",
    "title": "Polinomios",
    "section": "Factorización de polinomios",
    "text": "Factorización de polinomios\nSi lo que queremos es factorizar polinomios, primero tenemos que definir la variable, e indicar cuál es el anillo de coeficientes para nuestros polinomios. Luego se usa Factors igual que con enteros.\n\nx:=Indeterminate(ZmodnZ(5),\"x\");\n\nx\n\n\n\nTeachingMode();\n\n#I  Teaching mode is turned OFF\n\n\n\nFactors(x^2+1);\n\n[ x+Z(5), x+Z(5)^3 ]\n\n\nUsamos el modo enseñanza (TeachingMode) para visualizar mejor los elmeentos de \\(\\mathbb{Z}_5\\).\n\nTeachingMode(true);\n\n#I  Teaching mode is turned ON\n\n\n\nFactors(x^2+1);\n\n[ x+ZmodnZObj(2,5), x+ZmodnZObj(3,5) ]\n\n\n\nx:=Indeterminate(Rationals,\"x\");\n\nx\n\n\n\nFactors(x^2+1);\n\n[ x^2+1 ]\n\n\nLo mismo ocurre con las raices y con el hecho de ser irreducible.\n\nx:=Indeterminate(ZmodnZ(3),\"x\");\n\nx\n\n\n\nRootsOfUPol(x^3-1);\n\n[ ZmodnZObj(1,3), ZmodnZObj(1,3), ZmodnZObj(1,3) ]\n\n\n\nRootsOfUPol(x^3-1);\n\n[ ZmodnZObj(1,3), ZmodnZObj(1,3), ZmodnZObj(1,3) ]\n\n\n\nIsIrreducible(x^2+1);\n\ntrue\n\n\n\nx:=Indeterminate(ZmodnZ(2),\"x\");\n\nx\n\n\n\nIsIrreducible(x^2+1);\n\nfalse\n\n\nVeamos ahora a modo de ejemplo cómo calcular todos los polinomios irreducibles hasta un determinado grado en un anillo finito. Empezamos definiendo una función que nos genere todos los polinomios hasta un determinado grado.\n\npolshastagradomodm:=function(n,x)\n    local ps, R;\n    \n    R:=CoefficientsRing(DefaultRing(x));\n    if Size(R)=infinity then\n        return fail;\n    fi;\n    \n    if (n=0) then\n        return Elements(R);\n    fi;\n\n    ps:=polshastagradomodm(n-1,x);\n    return Set(Cartesian(ps,x^n*Elements(R)),Sum);\nend;\n\nfunction( n, x ) ... end\n\n\nAsí todos los polinomios en \\(\\mathbb{Z}_3\\) de grado menor o igual que dos son:\n\nx:=Indeterminate(ZmodnZ(3),\"x\");\n\nx\n\n\n\npolshastagradomodm(2,x);\n\n[ ZmodnZObj(0,3), ZmodnZObj(1,3), -ZmodnZObj(1,3), x, x+ZmodnZObj(1,3),   x-ZmodnZObj(1,3), -x, -x+ZmodnZObj(1,3), -x-ZmodnZObj(1,3), x^2,   x^2+ZmodnZObj(1,3), x^2-ZmodnZObj(1,3), x^2+x, x^2+x+ZmodnZObj(1,3),   x^2+x-ZmodnZObj(1,3), x^2-x, x^2-x+ZmodnZObj(1,3), x^2-x-ZmodnZObj(1,3),   -x^2, -x^2+ZmodnZObj(1,3), -x^2-ZmodnZObj(1,3), -x^2+x,   -x^2+x+ZmodnZObj(1,3), -x^2+x-ZmodnZObj(1,3), -x^2-x, -x^2-x+ZmodnZObj(1,3),  -x^2-x-ZmodnZObj(1,3) ]\n\n\nDe entre ellos podemos escoger los que son irreducibles.\n\nFiltered(polshastagradomodm(2,x), IsIrreducible);\n\n[ x, x+ZmodnZObj(1,3), x-ZmodnZObj(1,3), -x, -x+ZmodnZObj(1,3),   -x-ZmodnZObj(1,3), x^2+ZmodnZObj(1,3), x^2+x-ZmodnZObj(1,3),   x^2-x-ZmodnZObj(1,3), -x^2-ZmodnZObj(1,3), -x^2+x+ZmodnZObj(1,3),   -x^2-x+ZmodnZObj(1,3) ]\n\n\nY si queremos quedarnos con un representante salvo asociados, podemos usar lo siguiente.\n\nSet(Filtered(polshastagradomodm(2,x), IsIrreducible), StandardAssociate);\n\n[ x, x+ZmodnZObj(1,3), x-ZmodnZObj(1,3), x^2+ZmodnZObj(1,3),   x^2+x-ZmodnZObj(1,3), x^2-x-ZmodnZObj(1,3) ]",
    "crumbs": [
      "Polinomios"
    ]
  },
  {
    "objectID": "6 Polinomios.html#cociente-por-un-ideal.-cuerpos-finitos",
    "href": "6 Polinomios.html#cociente-por-un-ideal.-cuerpos-finitos",
    "title": "Polinomios",
    "section": "Cociente por un ideal. Cuerpos finitos",
    "text": "Cociente por un ideal. Cuerpos finitos\nIntentemos calcular los divisores de cero y unidades del anillo cociente \\(R=\\mathbb{Z}_2[x]/(x^2+1)\\). Empezamos definiendo nuestra variable y el módulo.\n\n x:=Indeterminate(ZmodnZ(2),\"x\");\n\nx\n\n\n\nmodulo:=x^2+1;\n\nx^2+ZmodnZObj(1,2)\n\n\nDefinimos \\(\\mathbb{Z}_2[x]\\), y luego hacemos el cociente por el ideal generado por modulo.\n\nP:=PolynomialRing(ZmodnZ(2),\"x\");\n\nGF(2)[x]\n\n\n\nR:=P/Ideal(P,[modulo]);\n\n&lt;ring GF(2),(1),(x)&gt;\n\n\n\nElements(R);\n\n[ 0*(1), (x), (1), (1)+(x) ]\n\n\nR es un anillo, y como tal podemos preguntarnos quién es su elemento neutro para la suma y para el producto.\n\nZero(R);\n\n0*(1)\n\n\n\nOne(R);\n\n(1)\n\n\nTambién podemos calcular el grupo de unidades de este anillo.\n\nUnits(R);\n\n&lt;group with 1 generator&gt;\n\n\n\nElements(Units(R));\n\n[ (x), (1) ]\n\n\nTenemos otra forma alternativa de hacer cocientes, que además nos permite hacer operaciones más fácilmente en el cociente.\n\ng:=NaturalHomomorphismByIdeal(P,Ideal(P,[modulo]));\n\n[ x, ZmodnZObj(1,2) ] -&gt; [ (x), (1) ]\n\n\n\nR:=Image(g);\n\n&lt;ring GF(2),(1),(x)&gt;\n\n\n\nImage(g,x^2+x);\n\n(1)+(x)\n\n\n\nclasex:=Image(g,x);\n\n(x)\n\n\n\nclasex^2+clasex;\n\n(1)+(x)\n\n\n\nPreImagesRepresentative(g,clasex^2);\n\nZmodnZObj(1,2)\n\n\nSi nuestro polinomio es irreducible, también podemos utilizar AlgebraicExtension.\n\nf:=x^2+x+1;\n\nx^2+x+ZmodnZObj(1,2)\n\n\n\nS:=AlgebraicExtension(ZmodnZ(2),f);\n\n&lt;field of size 4&gt;\n\n\nEn gap podemos usar cualquier cuerpo finito con el comando GF.\n\nK:=GF(9);\n\nGF(3^2)\n\n\n\nSize(K);\n\n9\n\n\n\nGeneratorsOfField(K);\n\n[ Z(9)^1 ]\n\n\n\nElements(K);\n\n[ ZmodnZObj(0,3), ZmodnZObj(1,3), ZmodnZObj(2,3), Z(9)^1, Z(9)^2, Z(9)^3,   Z(9)^5, Z(9)^6, Z(9)^7 ]\n\n\n\nGF(2^8);\n\nGF(2^8)",
    "crumbs": [
      "Polinomios"
    ]
  },
  {
    "objectID": "1 Primeros pasos.html",
    "href": "1 Primeros pasos.html",
    "title": "Primeros pasos con GAP",
    "section": "",
    "text": "gap es un entorno de cálculo algebraico discreto. Tiene un núcleo implementado en c y dispone aparte de librerías escritas en su propio lenguaje de programación.\nEste lenguaje es de tipo procedural, por lo que aquellas personas que han programado en pascal, c, maple, … no tienen problemas en adaptarse. En la página oficial de gap se puede encontrar abundante información concerniente a instalación en distintas plataformas, tutoriales, manuales, paquetes.\nLos paquetes pasan por un proceso de arbitraje similar al de las revistas científicas. Primero son depositados (y accesibles al público en la página oficial) y si se aceptan pasan a ser parte de la distribución. Aún así muchos instaladores incluyen los paquetes depositados.\ngap ha sido mantenido a lo largo de su historia por varias universidades, y se nutre de las contribuciones que hacen los usuarios en forma de paquetes para fines más específicos.",
    "crumbs": [
      "Primeros pasos"
    ]
  },
  {
    "objectID": "1 Primeros pasos.html#la-línea-de-comandos",
    "href": "1 Primeros pasos.html#la-línea-de-comandos",
    "title": "Primeros pasos con GAP",
    "section": "La línea de comandos",
    "text": "La línea de comandos\ngap es un lenguaje interpretado (aunque tiene un compilador). Se pueden hacer operaciones directamente en la línea de comandos o bien se pueden leer ficheros con guiones escritos con un editor de textos.\nNormalmente se invoca usando el comando gap, aunque dependiendo del sistema operativo pueden haber distintas alternativas. Una vez iniciado el intérprete aparece una línea de comandos con el siguiente aspecto.\ngap&gt;\nPara la edición de las entradas que queramos evaluar se pueden utilizar las flechas junto con las teclas de inicio y fin. Además existe la posibilidad de usar combinaciones de teclas similares a las de empleadas en un shell de unix (ctr-[b,f,p,n,a,e]). El tabulador sirve para completar comandos a partir del texto que hayamos introducido en ese momento. Así teclear Gcd+TAB da como resultado:\ngap&gt; Gcd\n    Gcd\n    GcdCoeffs\n    GcdInt\n    GcdOp\n    GcdRepresentation\n    GcdRepresentationOp\n    Gcdex\nPara salir de la línea de comandos podemos usar el comando quit;, o bien pulsar ctr-d.\nEl final de línea no se indica con el retorno de carro, sino con ; (para evaluar, se pulsa enter). Esto permite escribir sentencias de varias líneas.\ngap&gt; 1+\n&gt; 2;\n3\nEn jupyter para evaluar hay que pulsar mayúscula+enter.\n\n1+\n2;\n\n3\n\n\nLa sesión de trabajo se puede almacenar en un fichero para su posterior edición usando el comando LogTo. Con LogTo(\"pruebas/log\"); guardamos en el fichero log en la carpeta pruebas. Con LogTo(); interrumpimos la grabación.\nPodemos leer una secuencia de comandos (guión) con la orden Read (en este ejemplo uno.g contiene sólamente a:=1;).\n\nRead(\"pruebas/uno.g\");\n\n\na;\n\n1\n\n\nNótese que las barras son de la forma /, incluso en windows.\nA la ayuda se accede usando el signo de cierre de interrogación. Por ejmeplo, ?LogTo muestra ayuda sobre dicho comando.\nLas operaciones de suma y producto dependen de los argumentos que les acompañen. Así pueden representar suma de enteros, o de matrices, o de subespacios vectoriales… El producto puede significar incluso la composición de dos permutaciones, y el elevado (^) la imagen de un punto por una permutación.\n\n[1,2,3]+[1,2];\n\n[ 2, 4, 3 ]\n\n\n\n(1,2)*(2,5);\n\n(1,5,2)\n\n\n\n1^(1,2,3);\n\n2\n\n\nLos símbolos =, &lt;, &gt;, &lt;=, &gt; = y &lt;&gt; sirven para denotar igualdad, ser mayor, menor, menor o igual, mayor o igual y distinto, respectivamente.\n\n2=1+1;\n\ntrue\n\n\n\n[1,2]&lt;[3];\n\ntrue\n\n\n\n[1,2]&gt;[1,3];\n\nfalse\n\n\n\n1&lt;&gt;1;\n\nfalse",
    "crumbs": [
      "Primeros pasos"
    ]
  },
  {
    "objectID": "1 Primeros pasos.html#registros",
    "href": "1 Primeros pasos.html#registros",
    "title": "Primeros pasos con GAP",
    "section": "Registros",
    "text": "Registros\nEn gap podemos crear registros con campos personalizados utilizando rec.\n\nr:=rec(a:=1,b:=\"2\");\n\nrec( a := 1, b := \"2\" )\n\n\nPodemos añadir nuevos campos, o modificar los existentes, simplemente asignándoles un valor.\n\nr.c:=rec(d:=1,e:=3);\n\nrec( d := 1, e := 3 )\n\n\n\nr;\n\nrec( a := 1, b := \"2\", c := rec( d := 1, e := 3 ) )\n\n\n\nr.a:=5;\n\n5\n\n\n\nr;\n\nrec( a := 5, b := \"2\", c := rec( d := 1, e := 3 ) )\n\n\nPara acceder al valor de un campo, utilizamos ..\n\nr.c.d;\n\n1\n\n\nPodemos ver los campos definidos con RecNames.\n\nRecNames(r);\n\n[ \"b\", \"a\", \"c\" ]\n\n\nO ver si un campo está asignado o no\n\nIsBound(r.g);\n\nfalse\n\n\n\nUnbind(r.b);\n\n\nr;\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )\n\n\nAl igual que en listas, si queremos hacer una copia, es recomendable utilizar ShallowCopy.\n\nrr:=ShallowCopy(r);\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )\n\n\n\nrr.c.d:=4;\n\n4\n\n\n\nr;\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\nEl problema aquí es que r contiene a su vez otro registro. Para evitar esto, utilizamos StructuralCopy.\n\nrr:=StructuralCopy(r);\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\n\nrr.c.d:=1;\n\n1\n\n\n\nr;\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\n\nrr;\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )",
    "crumbs": [
      "Primeros pasos"
    ]
  },
  {
    "objectID": "1 First steps.html",
    "href": "1 First steps.html",
    "title": "First steps in GAP",
    "section": "",
    "text": "GAP is a discrete algebraic computing environment (GAP stands for Groups, Algorithms, and Programming). It has a core implemented in c and has separate libraries written in its own programming language.\nThis language is procedural, so people who have programmed in pascal, c, maple, … have no problems in adapting. On the official GAP website you can find a lot of information concerning installation on different platforms, tutorials, manuals, and packages.\nGAP packages go through a refereeing process similar to that of scientific journals. They are first deposited (and publicly accessible on the official website) and if accepted they become part of the distribution.\nGAP has been maintained throughout its history by several universities, and is supported by contributions from users in the form of packages for more specific purposes."
  },
  {
    "objectID": "1 First steps.html#command-line",
    "href": "1 First steps.html#command-line",
    "title": "First steps in GAP",
    "section": "Command line",
    "text": "Command line\nGAP is an interpreted language (although it has a compiler). Operations can be performed directly on the command line, or scripted files written in a text editor can be read.\nGAP is normally invoked using the gap command, although depending on the operating system there may be different alternatives. Once the interpreter is started, a command line appears that looks like this.\ngap&gt;\nTo edit the entries you want to evaluate, you can use the arrow keys together with the start and end keys. There is also the possibility of using key combinations similar to those used in a unix shell (ctr-[b,f,p,n,a,e]). The tab key is used to complete commands from the text you have entered at that moment. Thus typing Gcd+TAB results in:\ngap&gt; Gcd\n    Gcd\n    GcdCoeffs\n    GcdInt\n    GcdOp\n    GcdRepresentation\n    GcdRepresentationOp\n    Gcdex\nTo exit the command line, you can use the command quit;, or press ctr-d.\nThe end of a line is not indicated by a carriage return, but by ; (to evaluate, press enter). This allows you to write multi-line statements.\ngap&gt; 1+\n&gt; 2;\n3\nOn jupyter to evaluate you have to press shift+enter.\n\n1+\n2+3;\n\n6\n\n\nThe working session can be stored in a file for later editing using the LogTo command. With LogTo(\"tests/log\"); we save to the log file in the tests folder. With LogTo(); we interrupt the recording.\nWe can read a script with the Read command (in this example one.g contains only a:=1;).\n\nRead(\"pruebas/uno.g\");\n\n\na;\n\n1\n\n\nNote that the slashes are in the form /, even on windows.\nHelp is accessed using a question mark. For example, ?LogTo shows help for that command.\nThe operations of addition and product depend on the arguments that accompany them. They can represent the sum of integers, or of matrices, or of vector subspaces… The product can even mean the composition of two permutations, and the power (^) the image of a point by a permutation.\n\n[1,2,3]+[1,2,7,8];\n\n[ 2, 4, 10, 8 ]\n\n\n\n(1,2)*(2,5);\n\n(1,5,2)\n\n\n\n1^(1,2,3);\n\n2\n\n\nThe symbols =, &lt;, &gt;, &lt;=, &gt;=, and &lt;&gt; are used to denote equality, less than, greater than, less than or equal, greater than or equal, and different, respectively sirven para denotar igualdad, ser mayor, menor, menor o igual, mayor o igual y distinto, respectivamente.\n\n2=1+1;\n\ntrue\n\n\n\n[1,2]&lt;[3];\n\ntrue\n\n\n\n[1,2]&gt;[1,3];\n\nfalse\n\n\n\n1&lt;&gt;1;\n\nfalse"
  },
  {
    "objectID": "1 First steps.html#registers",
    "href": "1 First steps.html#registers",
    "title": "First steps in GAP",
    "section": "Registers",
    "text": "Registers\nIn gap we can create records with custom fields using rec.\n\nr:=rec(a:=1,b:=\"2\");\n\nrec( a := 1, b := \"2\" )\n\n\nWe can add new fields, or modify existing ones, simply by assigning them a value.\n\nr.c:=rec(d:=1,e:=3);\n\nrec( d := 1, e := 3 )\n\n\n\nr;\n\nrec( a := 1, b := \"2\", c := rec( d := 1, e := 3 ) )\n\n\n\nr.a:=5;\n\n5\n\n\n\nr;\n\nrec( a := 5, b := \"2\", c := rec( d := 1, e := 3 ) )\n\n\nTo access a field value, we use ..\n\nr.c.d;\n\n1\n\n\nWe can see the fields defined with RecNames.\n\nRecNames(r);\n\n[ \"b\", \"a\", \"c\" ]\n\n\nOr see whether a field is assigned or not\n\nIsBound(r.g);\n\nfalse\n\n\n\nUnbind(r.b);\n\n\nr;\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )\n\n\nAs with lists, if you want to make a copy, it is advisable to use ShallowCopy.\n\nrr:=ShallowCopy(r);\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )\n\n\n\nrr.c.d:=4;\n\n4\n\n\n\nr;\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\nThe problem here is that r itself contains another record. To avoid this, we use StructuralCopy.\n\nrr:=StructuralCopy(r);\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\n\nrr.c.d:=1;\n\n1\n\n\n\nr;\n\nrec( a := 5, c := rec( d := 4, e := 3 ) )\n\n\n\nrr;\n\nrec( a := 5, c := rec( d := 1, e := 3 ) )"
  }
]